/**
  * Generated by API Builder - https://www.apibuilder.io
  * Service version: 0.0.1-dev
  * apibuilder 0.14.75 localhost 9000/michal/playground-api/0.0.1-dev/http4s_0_20
  */
package io.github.mkows.playground.api.v0.models {

  sealed trait ItemState extends _root_.scala.Product with _root_.scala.Serializable

  /**
    * Defines the valid type values for the type ItemState
    */
  sealed trait ItemStateType extends _root_.scala.Product with _root_.scala.Serializable

  object ItemStateType {

    case object ItemStateProgress extends ItemStateType { override def toString = "item_state_progress" }
    case object ItemStateFailedCause extends ItemStateType { override def toString = "item_state_failed_cause" }

    final case class UNDEFINED(override val toString: String) extends ItemStateType

    val all: scala.List[ItemStateType] = scala.List(ItemStateProgress, ItemStateFailedCause)

    private[this] val byName: Map[String, ItemStateType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ItemStateType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ItemStateType] = byName.get(value.toLowerCase)

  }

  final case class Error(
    code: Int,
    message: String,
    details: _root_.scala.Option[String] = None
  )

  final case class Healthcheck(
    status: String,
    createdAt: _root_.java.time.Instant
  )

  /**
    * Provides future compatibility in clients - in the future, when a type is added
    * to the union ItemState, it will need to be handled in the client code. This
    * implementation will deserialize these future types as an instance of this class.
    *
    * @param description Information about the type that we received that is undefined in this version of
    *        the client.
    */
  final case class ItemStateUndefinedType(
    description: String
  ) extends ItemState

  sealed trait ItemStateFailedCause extends ItemState

  object ItemStateFailedCause {

    case object ErrorCause1 extends ItemStateFailedCause { override def toString = "ErrorCause1" }
    case object ErrorCause2 extends ItemStateFailedCause { override def toString = "ErrorCause2" }
    case object ErrorCause3 extends ItemStateFailedCause { override def toString = "ErrorCause3" }

    /**
      * UNDEFINED captures values that are sent either in error or
      * that were added by the server after this library was
      * generated. We want to make it easy and obvious for users of
      * this library to handle this case gracefully.
      *
      * We use all CAPS for the variable name to avoid collisions
      * with the camel cased values above.
      */
    final case class UNDEFINED(override val toString: String) extends ItemStateFailedCause

    /**
      * all returns a list of all the valid, known values. We use
      * lower case to avoid collisions with the camel cased values
      * above.
      */
    val all: scala.List[ItemStateFailedCause] = scala.List(ErrorCause1, ErrorCause2, ErrorCause3)

    private[this]
    val byName: Map[String, ItemStateFailedCause] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ItemStateFailedCause = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ItemStateFailedCause] = byName.get(value.toLowerCase)

  }

  sealed trait ItemStateProgress extends ItemState

  object ItemStateProgress {

    case object Init extends ItemStateProgress { override def toString = "Init" }
    case object Pending extends ItemStateProgress { override def toString = "Pending" }
    case object Completed extends ItemStateProgress { override def toString = "Completed" }

    /**
      * UNDEFINED captures values that are sent either in error or
      * that were added by the server after this library was
      * generated. We want to make it easy and obvious for users of
      * this library to handle this case gracefully.
      *
      * We use all CAPS for the variable name to avoid collisions
      * with the camel cased values above.
      */
    final case class UNDEFINED(override val toString: String) extends ItemStateProgress

    /**
      * all returns a list of all the valid, known values. We use
      * lower case to avoid collisions with the camel cased values
      * above.
      */
    val all: scala.List[ItemStateProgress] = scala.List(Init, Pending, Completed)

    private[this]
    val byName: Map[String, ItemStateProgress] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ItemStateProgress = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ItemStateProgress] = byName.get(value.toLowerCase)

  }

}

package io.github.mkows.playground.api.v0.models {

  package object json {
    import io.circe.Decoder._
    import io.circe.Encoder._
    import scala.language.implicitConversions // See below - Make Scala 2.11 Either monadic
    import scala.util.Try
    import io.circe.{Json, JsonObject, Encoder, Decoder, DecodingFailure}
    import io.circe.syntax._
    import io.github.mkows.playground.api.v0.models.json._

    // Make Scala 2.11 Either monadic
    private[v0] implicit def eitherOps[A,B](e: Either[A,B]) = cats.implicits.catsSyntaxEither(e)

    private[v0] implicit val decodeUUID: Decoder[_root_.java.util.UUID] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.util.UUID.fromString(str)))

    private[v0] implicit val encodeUUID: Encoder[_root_.java.util.UUID] =
      Encoder.encodeString.contramap[_root_.java.util.UUID](_.toString)

    private[v0] implicit val decodeInstant: Decoder[_root_.java.time.Instant] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.Instant.parse(str)))

    private[v0] implicit val encodeInstant: Encoder[_root_.java.time.Instant] =
      Encoder.encodeString.contramap[_root_.java.time.Instant](_.toString)

    private[v0] implicit val decodeLocalDate: Decoder[_root_.java.time.LocalDate] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.LocalDate.parse(str)))

    private[v0] implicit val encodeLocalDate: Encoder[_root_.java.time.LocalDate] =
      Encoder.encodeString.contramap[_root_.java.time.LocalDate](_.toString)

    implicit val jsonDecoderPlaygroundApiItemStateFailedCause: Decoder[io.github.mkows.playground.api.v0.models.ItemStateFailedCause] =
      Decoder.decodeString.map(io.github.mkows.playground.api.v0.models.ItemStateFailedCause(_))

    implicit val jsonEncoderPlaygroundApiItemStateFailedCause: Encoder[io.github.mkows.playground.api.v0.models.ItemStateFailedCause] =
      Encoder.encodeString.contramap[io.github.mkows.playground.api.v0.models.ItemStateFailedCause](_.toString)

    implicit val jsonDecoderPlaygroundApiItemStateProgress: Decoder[io.github.mkows.playground.api.v0.models.ItemStateProgress] =
      Decoder.decodeString.map(io.github.mkows.playground.api.v0.models.ItemStateProgress(_))

    implicit val jsonEncoderPlaygroundApiItemStateProgress: Encoder[io.github.mkows.playground.api.v0.models.ItemStateProgress] =
      Encoder.encodeString.contramap[io.github.mkows.playground.api.v0.models.ItemStateProgress](_.toString)

    implicit def decodePlaygroundApiError: Decoder[Error] = Decoder.instance { c =>
      for {
        code <- c.downField("code").as[Int]
        message <- c.downField("message").as[String]
        details <- c.downField("details").as[Option[String]]
      } yield {
        Error(
          code = code,
          message = message,
          details = details
        )
      }
    }

    implicit def encodePlaygroundApiError: Encoder[Error] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("code" -> t.code.asJson),
        Some("message" -> t.message.asJson),
        t.details.map(t => "details" -> t.asJson)
      ).flatten)
    }

    implicit def decodePlaygroundApiHealthcheck: Decoder[Healthcheck] = Decoder.instance { c =>
      for {
        status <- c.downField("status").as[String]
        createdAt <- c.downField("created_at").as[_root_.java.time.Instant]
      } yield {
        Healthcheck(
          status = status,
          createdAt = createdAt
        )
      }
    }

    implicit def encodePlaygroundApiHealthcheck: Encoder[Healthcheck] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("status" -> t.status.asJson),
        Some("created_at" -> t.createdAt.asJson)
      ).flatten)
    }

    implicit def decodePlaygroundApiItemState: Decoder[ItemState] = Decoder.instance { c =>
      c.get[Option[String]]("type") match {
        case Right(Some(s)) if s == "item_state_progress" => c.as[io.github.mkows.playground.api.v0.models.ItemStateProgress]
        case Right(Some(s)) if s == "item_state_failed_cause" => c.as[io.github.mkows.playground.api.v0.models.ItemStateFailedCause]
        case Right(Some(s)) => Right(io.github.mkows.playground.api.v0.models.ItemStateUndefinedType(s))
        case _ => Left(DecodingFailure("Union[ItemState] requires a discriminator named 'type' - this field was not found in the Json", c.history))
      }
    }

    implicit def encodePlaygroundApiItemState: Encoder[ItemState] = Encoder.instance {
      case t: io.github.mkows.playground.api.v0.models.ItemStateProgress => t.asJson.mapObject(obj => ("type", Json.fromString("item_state_progress")) +: obj)
      case t: io.github.mkows.playground.api.v0.models.ItemStateFailedCause => t.asJson.mapObject(obj => ("type", Json.fromString("item_state_failed_cause")) +: obj)
      case other => sys.error(s"The type[${other.getClass.getName}] has no JSON encoder")
    }
  }
}