/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.0.2-dev
 * apibuilder 0.14.75 localhost 9000/michal/playground-api/0.0.2-dev/http4s_0_18
 */
package io.github.mkows.playground.api.v0.models {

  sealed trait ItemState extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid type values for the type ItemState
   */
  sealed trait ItemStateType extends _root_.scala.Product with _root_.scala.Serializable

  object ItemStateType {

    case object ItemStateProgress extends ItemStateType { override def toString = "item_state_progress" }
    case object ItemStateFailedCause extends ItemStateType { override def toString = "item_state_failed_cause" }

    final case class UNDEFINED(override val toString: String) extends ItemStateType

    val all: scala.List[ItemStateType] = scala.List(ItemStateProgress, ItemStateFailedCause)

    private[this] val byName: Map[String, ItemStateType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ItemStateType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ItemStateType] = byName.get(value.toLowerCase)

  }

  final case class Error(
    code: Int,
    message: String,
    messageCode: String,
    messageLengthy: String,
    details: _root_.scala.Option[String] = None
  )

  final case class Healthcheck(
    status: String,
    createdAt: _root_.java.time.Instant
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ItemState, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ItemStateUndefinedType(
    description: String
  ) extends ItemState

  sealed trait ItemStateFailedCause extends ItemState

  object ItemStateFailedCause {

    case object ErrorCause1 extends ItemStateFailedCause { override def toString = "ErrorCause1" }
    case object ErrorCause2 extends ItemStateFailedCause { override def toString = "ErrorCause2" }
    case object ErrorCause3 extends ItemStateFailedCause { override def toString = "ErrorCause3" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ItemStateFailedCause

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ItemStateFailedCause] = scala.List(ErrorCause1, ErrorCause2, ErrorCause3)

    private[this]
    val byName: Map[String, ItemStateFailedCause] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ItemStateFailedCause = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ItemStateFailedCause] = byName.get(value.toLowerCase)

  }

  sealed trait ItemStateProgress extends ItemState

  object ItemStateProgress {

    case object Init extends ItemStateProgress { override def toString = "Init" }
    case object Pending extends ItemStateProgress { override def toString = "Pending" }
    case object Completed extends ItemStateProgress { override def toString = "Completed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ItemStateProgress

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ItemStateProgress] = scala.List(Init, Pending, Completed)

    private[this]
    val byName: Map[String, ItemStateProgress] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ItemStateProgress = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ItemStateProgress] = byName.get(value.toLowerCase)

  }

}

package io.github.mkows.playground.api.v0.models {

  package object json {
    import io.circe.Decoder._
    import io.circe.Encoder._
    import scala.language.implicitConversions // See below - Make Scala 2.11 Either monadic
    import scala.util.Try
    import io.circe.{Json, JsonObject, Encoder, Decoder, DecodingFailure}
    import io.circe.syntax._
    import io.github.mkows.playground.api.v0.models.json._

    // Make Scala 2.11 Either monadic
    private[v0] implicit def eitherOps[A,B](e: Either[A,B]) = cats.implicits.catsSyntaxEither(e)

    private[v0] implicit val decodeUUID: Decoder[_root_.java.util.UUID] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.util.UUID.fromString(str)))

    private[v0] implicit val encodeUUID: Encoder[_root_.java.util.UUID] =
      Encoder.encodeString.contramap[_root_.java.util.UUID](_.toString)

    private[v0] implicit val decodeInstant: Decoder[_root_.java.time.Instant] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.Instant.parse(str)))

    private[v0] implicit val encodeInstant: Encoder[_root_.java.time.Instant] =
      Encoder.encodeString.contramap[_root_.java.time.Instant](_.toString)

    private[v0] implicit val decodeLocalDate: Decoder[_root_.java.time.LocalDate] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.LocalDate.parse(str)))

    private[v0] implicit val encodeLocalDate: Encoder[_root_.java.time.LocalDate] =
      Encoder.encodeString.contramap[_root_.java.time.LocalDate](_.toString)

    implicit val jsonDecoderPlaygroundApiItemStateFailedCause: Decoder[io.github.mkows.playground.api.v0.models.ItemStateFailedCause] =
      Decoder.decodeString.map(io.github.mkows.playground.api.v0.models.ItemStateFailedCause(_))

    implicit val jsonEncoderPlaygroundApiItemStateFailedCause: Encoder[io.github.mkows.playground.api.v0.models.ItemStateFailedCause] =
      Encoder.encodeString.contramap[io.github.mkows.playground.api.v0.models.ItemStateFailedCause](_.toString)

    implicit val jsonDecoderPlaygroundApiItemStateProgress: Decoder[io.github.mkows.playground.api.v0.models.ItemStateProgress] =
      Decoder.decodeString.map(io.github.mkows.playground.api.v0.models.ItemStateProgress(_))

    implicit val jsonEncoderPlaygroundApiItemStateProgress: Encoder[io.github.mkows.playground.api.v0.models.ItemStateProgress] =
      Encoder.encodeString.contramap[io.github.mkows.playground.api.v0.models.ItemStateProgress](_.toString)

    implicit def decodePlaygroundApiError: Decoder[Error] = Decoder.instance { c =>
     for {
        code <- c.downField("code").as[Int]
        message <- c.downField("message").as[String]
        messageCode <- c.downField("message_code").as[String]
        messageLengthy <- c.downField("message_lengthy").as[String]
        details <- c.downField("details").as[Option[String]]
      } yield {
        Error(
          code = code,
          message = message,
          messageCode = messageCode,
          messageLengthy = messageLengthy,
          details = details
        )
      }
    }

    implicit def encodePlaygroundApiError: Encoder[Error] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("code" -> t.code.asJson),
        Some("message" -> t.message.asJson),
        Some("message_code" -> t.messageCode.asJson),
        Some("message_lengthy" -> t.messageLengthy.asJson),
        t.details.map(t => "details" -> t.asJson)
      ).flatten)
    }

    implicit def decodePlaygroundApiHealthcheck: Decoder[Healthcheck] = Decoder.instance { c =>
     for {
        status <- c.downField("status").as[String]
        createdAt <- c.downField("created_at").as[_root_.java.time.Instant]
      } yield {
        Healthcheck(
          status = status,
          createdAt = createdAt
        )
      }
    }

    implicit def encodePlaygroundApiHealthcheck: Encoder[Healthcheck] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("status" -> t.status.asJson),
        Some("created_at" -> t.createdAt.asJson)
      ).flatten)
    }

    implicit def decodePlaygroundApiItemState: Decoder[ItemState] = Decoder.instance { c =>
      c.get[Option[String]]("type") match {
        case Right(Some(s)) if s == "item_state_progress" => c.as[io.github.mkows.playground.api.v0.models.ItemStateProgress]
        case Right(Some(s)) if s == "item_state_failed_cause" => c.as[io.github.mkows.playground.api.v0.models.ItemStateFailedCause]
        case Right(Some(s)) => Right(io.github.mkows.playground.api.v0.models.ItemStateUndefinedType(s))
        case _ => Left(DecodingFailure("Union[ItemState] requires a discriminator named 'type' - this field was not found in the Json", c.history))
      }
    }

    implicit def encodePlaygroundApiItemState: Encoder[ItemState] = Encoder.instance {
      case t: io.github.mkows.playground.api.v0.models.ItemStateProgress => t.asJson.mapObject(obj => ("type", Json.fromString("item_state_progress")) +: obj)
      case t: io.github.mkows.playground.api.v0.models.ItemStateFailedCause => t.asJson.mapObject(obj => ("type", Json.fromString("item_state_failed_cause")) +: obj)
      case other => sys.error(s"The type[${other.getClass.getName}] has no JSON encoder")
    }
  }
}

package io.github.mkows.playground.api.v0 {
import cats.effect._
import cats.implicits._
import io.circe.syntax._
import scala.language.higherKinds

  object Constants {

    val BaseUrl = "https://mkows.github.io"
    val Namespace = "io.github.mkows.playground.api.v0"
    val UserAgent = "apibuilder 0.14.75 localhost 9000/michal/playground-api/0.0.2-dev/http4s_0_18"
    val Version = "0.0.2-dev"
    val VersionMajor = 0

  }

  class Client[F[_]: Sync](
    val baseUrl: org.http4s.Uri = org.http4s.Uri.unsafeFromString("https://mkows.github.io"),
    auth: scala.Option[io.github.mkows.playground.api.v0.Authorization] = None,
    defaultHeaders: Seq[(String, String)] = Nil,
    httpClient: org.http4s.client.Client[F]
  ) extends interfaces.Client[F] {
    import org.http4s.Response
    import io.github.mkows.playground.api.v0.models.json._


    def healthchecks: Healthchecks[F] = Healthchecks

    object Healthchecks extends Healthchecks[F] {
      override def get(
        requestHeaders: Seq[(String, String)] = Nil
      ): F[io.github.mkows.playground.api.v0.models.Healthcheck] = {
        val urlPath = Seq("_internal_", "healthcheck")

        _executeRequest[Unit, io.github.mkows.playground.api.v0.models.Healthcheck]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.github.mkows.playground.api.v0.Client.parseJson[F, io.github.mkows.playground.api.v0.models.Healthcheck]("io.github.mkows.playground.api.v0.models.Healthcheck", r)
          case r => Sync[F].raiseError(new io.github.mkows.playground.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }

      override def postTestFormParamsJson(
        param1: String,
        requestHeaders: Seq[(String, String)] = Nil
      ): F[Unit] = {
        val urlPath = Seq("_internal_", "healthcheck", "test_form_params_json")

        val payload = None
        val formPayload = Some(org.http4s.UrlForm(
          "param1" -> param1
        ))

        _executeRequest[Unit, Unit]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => Sync[F].pure(())
          case r => Sync[F].raiseError(new io.github.mkows.playground.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204"))
        }
      }

      override def getById(
        id: Int,
        requestHeaders: Seq[(String, String)] = Nil
      ): F[io.github.mkows.playground.api.v0.models.Healthcheck] = {
        val urlPath = Seq("_internal_", "healthcheck", id.toString)

        _executeRequest[Unit, io.github.mkows.playground.api.v0.models.Healthcheck]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.github.mkows.playground.api.v0.Client.parseJson[F, io.github.mkows.playground.api.v0.models.Healthcheck]("io.github.mkows.playground.api.v0.models.Healthcheck", r)
          case r if r.status.code == 400 => _root_.io.github.mkows.playground.api.v0.Client.parseJson[F, io.github.mkows.playground.api.v0.models.Error]("io.github.mkows.playground.api.v0.models.Error", r).flatMap(body => Sync[F].raiseError(new io.github.mkows.playground.api.v0.errors.ErrorResponse(r.headers, r.status.code, None, body)))
          case r if r.status.code == 401 => Sync[F].raiseError(new io.github.mkows.playground.api.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 403 => _root_.io.github.mkows.playground.api.v0.Client.parseJson[F, String]("String", r).flatMap(body => Sync[F].raiseError(new io.github.mkows.playground.api.v0.errors.ValueResponse(r.headers, r.status.code, None, body)))
          case r if r.status.code == 404 => Sync[F].raiseError(new io.github.mkows.playground.api.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.github.mkows.playground.api.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 400, 401, 403, 404"))
        }
      }
    }

    private lazy val defaultApiHeaders = Seq(
      ("User-Agent", Constants.UserAgent),
      ("X-Apidoc-Version", Constants.Version),
      ("X-Apidoc-Version-Major", Constants.VersionMajor.toString)
    )

    def apiHeaders: Seq[(String, String)] = defaultApiHeaders

    def modifyRequest(request: F[org.http4s.Request[F]]): F[org.http4s.Request[F]] = request

    implicit def circeJsonEncoder[F[_]: Sync, A](implicit encoder: io.circe.Encoder[A]) = org.http4s.circe.jsonEncoderOf[F, A]

    def _executeRequest[T, U](
      method: String,
      path: Seq[String],
      queryParameters: Seq[(String, String)] = Nil,
      requestHeaders: Seq[(String, String)] = Nil,
      body: Option[T] = None,
      formBody : Option[org.http4s.UrlForm] = None
    )(handler: org.http4s.Response[F] => F[U]
    )(implicit encoder: io.circe.Encoder[T]): F[U] = {
      import org.http4s.QueryParamEncoder._

      val m = org.http4s.Method.fromString(method) match {
        case Right(m) => m
        case Left(e) => sys.error(e.toString)
      }

      val headers = org.http4s.Headers((
        apiHeaders ++
        defaultHeaders ++
        requestHeaders
      ).toList.map { case (k, v) => org.http4s.Header(k, v) })

      val queryMap = queryParameters.groupBy(_._1).map { case (k, v) => k -> v.map(_._2) }
      val uri = path.foldLeft(baseUrl){ case (uri, segment) => uri / segment }.setQueryParams(queryMap)

      val request = org.http4s.Request[F](method = m,
                                       uri = uri,
                                       headers = headers)

      val reqAndMaybeAuth = auth.fold(request) {
        case Authorization.Basic(username, passwordOpt) => {
          val userpass = s"$username:${passwordOpt.getOrElse("")}"
          val token = java.util.Base64.getEncoder.encodeToString(userpass.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1))
          request.putHeaders(org.http4s.Header("Authorization", s"Basic $token"))
        }
        case a => sys.error("Invalid authorization scheme[" + a.getClass + "]")
      }

      val reqAndMaybeAuthAndBody =
        if (formBody.nonEmpty) formBody.fold(Sync[F].pure(reqAndMaybeAuth))(reqAndMaybeAuth.withBody)
        else body.fold(Sync[F].pure(reqAndMaybeAuth))(reqAndMaybeAuth.withBody)

      httpClient.fetch(modifyRequest(reqAndMaybeAuthAndBody))(handler)
    }
  }

  object Client {
    import cats.effect._

    implicit def circeJsonDecoder[F[_]: Sync, A](implicit decoder: io.circe.Decoder[A]) = org.http4s.circe.jsonOf[F, A]

    def parseJson[F[_]: Sync, T](
      className: String,
      r: org.http4s.Response[F]
    )(implicit decoder: io.circe.Decoder[T]): F[T] = r.attemptAs[T].value.flatMap {
      case Right(value) => Sync[F].pure(value)
      case Left(error) => Sync[F].raiseError(new io.github.mkows.playground.api.v0.errors.FailedRequest(r.status.code, s"Invalid json for class[" + className + "]", None, error))
    }
  }

  sealed trait Authorization extends _root_.scala.Product with _root_.scala.Serializable
  object Authorization {
    final case class Basic(username: String, password: Option[String] = None) extends Authorization
  }

  package interfaces {

    trait Client[F[_]] {
      def baseUrl: org.http4s.Uri
      def healthchecks: io.github.mkows.playground.api.v0.Healthchecks[F]
    }

  }

  trait Healthchecks[F[_]] {
    def get(
      requestHeaders: Seq[(String, String)] = Nil
    ): F[io.github.mkows.playground.api.v0.models.Healthcheck]

    def postTestFormParamsJson(
      param1: String,
      requestHeaders: Seq[(String, String)] = Nil
    ): F[Unit]

    def getById(
      id: Int,
      requestHeaders: Seq[(String, String)] = Nil
    ): F[io.github.mkows.playground.api.v0.models.Healthcheck]
  }

  package errors {

    final case class ErrorResponse(
      headers: org.http4s.Headers,
      status: Int,
      message: Option[String] = None,
      body: io.github.mkows.playground.api.v0.models.Error
    ) extends Exception(s"HTTP $status${message.fold("")(m => s": $m")}"){
      lazy val error = body
    }

    final case class UnitResponse(status: Int) extends Exception(s"HTTP $status")

    final case class ValueResponse(
      headers: org.http4s.Headers,
      status: Int,
      message: Option[String] = None,
      body: String
    ) extends Exception(s"HTTP $status${message.fold("")(m => s": $m")}"){
      lazy val value = body
    }

    final case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None, parent: Exception = null) extends _root_.java.lang.Exception(s"HTTP $responseCode: $message", parent)

  }
}